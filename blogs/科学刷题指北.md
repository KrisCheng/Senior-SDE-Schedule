# 科学刷题指北

> “科学刷题就是伪命题，多刷多总结才是王道。”

本页面用于记录个人的刷题记录（尤其是那些有意思，有启发，好玩的编程题）。部分附个人面试公司， *`TODO`* 表示准备面试前需重点关注的地方，根据具体题型分类。



### 排序相关

* **手写主流排序算法 & 各种算法的复杂度/稳定性分析（腾讯/头条/阿里/蜻蜓FM）**
  * 常见问题
    * 手写快排 / 堆排
    * 快排的复杂度分析（最好/最坏/平均）
    * 堆排中建堆的时间复杂度分析  --> O(n)
    * 归并排序的 Top-Down & Bottom-up 策略
    * 不同排序的稳定性分析
    * 冒泡排序的优化策略（华为）
      * 设置flag位，一轮未交换即已完成排序，提前结束
      * 记住本轮最后一次交换发生的位置lastExchange，下次内层循环到此终止即可
  * [排序算法稳定性](https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%A8%B3%E5%AE%9A%E6%80%A7)
  * [排序算法可视化](https://visualgo.net/en/sorting)
  * [快排 Wiki](https://zh.wikipedia.org/zh/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F)
  * [堆排 Wiki](https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F)（ 堆排的纯代码实现 *`TODO`*）
  * [归并排序 Wiki](https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F)（ 递归版本和循环版本的代码实现 *`TODO`*）
  * [冒泡排序算法及其两种优化](https://blog.csdn.net/yanxiaolx/article/details/51622286)
* **（Top K 问题）给定一个无符号，包含10亿个数的数组，如何取出前100大的数（头条/腾讯）**
  * 答题思路
    * 首先询问资源 --> 内存 / 核数 / 单机or多机，如可用多机 --> MapReduce思想
    * 堆排 O(nlogk)，可以单机处理海量数据（在内存受限情况下），如果k较小，趋近于 O(n)
      * 建立一个容量为k的大/小顶堆
      * n个元素逐一比较，O(logk) 完成删除和插入操作
    * 全局排序， O(nlogn) （数据量较小时才可行）
    * 冒泡（k个），O(kn)
    * 快排划分 O(n)， 每次递归处理一侧的数据，理论上可以理解为每次折半，缺点 --> 存在内存不够的问题，因为需要一次读入所有数据
  * [算法必学：经典的 Top K 问题](https://juejin.im/entry/5c565fb7f265da2d84105958)（基本思路篇）
  * [海量数据处理 - 10亿个数中找出最大的10000个数（top K问题）](https://blog.csdn.net/zyq522376829/article/details/47686867) （各种资源场景分析，面试前可看）
  * [最小的K个数](https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tqId=11182&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)（代码实现，首选堆排）
* **如何给一个很大的无序数组去重（腾讯）**
  * [26. 删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)（给排序数组去重）
* **求两个排序数组的中位数（依图）** *`TODO`* 
  * 要求时间复杂度 O(log(m+n)) 
  * 思路为二分查找，递归求整个数组中第K大的元素，代码需要仔细考虑多种边界条件
  * [4.寻找两个有序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/) 


* **从一大段文本中找出TOP K 的高频词汇**

  * [System Design Interview - Top K Problem (Heavy Hitters)](https://www.youtube.com/watch?v=kx-XDoPjoHw) （系统设计角度思考本题，如何权衡性能和效率，较为高阶，可之后再看 *`TODO`* ）
  * [347. 前K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/) （数字频次代码实现，建堆，时间复杂度为nlog(k)）
  * [692. 前K个高频单词](https://leetcode-cn.com/problems/top-k-frequent-words/) （词汇频次代码实现，思路一致）
* **如何找到一个无序数组的中位数**

  * [295. 数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/) （建立两个堆，最大堆&最小堆）
  * [找出一个无序数组的中位数](https://blog.csdn.net/oneday_789/article/details/76681764) （快排，缩小partition区域or取一半元素建堆）
* **数组中的逆序对** *`TODO`* 
  * 归并排序 && 递归的应用
  * 引入辅助数组临时存放排序好的数据
  * 归并时指向两个指针末尾，逐次向前并统计
  * [数组中的逆序对](https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tqId=11188&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 


* **链表排序** *`TODO`*
  * 需要 nlog(n) 时间复杂度和常数级空间复杂度
  * 归并排序的应用（Bottom Up）
  * 找到中点，断开链表（通过快慢两个指针）
  * 交替双指针合并
  * [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)


* **Java自带的 sort() 方法是如何实现的（阿里）**
  * Array.sort() / Collections.sort()
  * DualPivotQuicksort（双轴快速排序）
  * [Arrays.sort和Collections.sort实现原理解析](https://blog.csdn.net/u011410529/article/details/56668545)
  * [Collections.sort()和Arrays.sort()排序算法选择](https://blog.csdn.net/TimHeath/article/details/68930482)



### 树

* **二叉树的遍历**
  * 引入一种新的数据结构形成通用解法（Value + 是否访问过的标识符）
  * 使用一个队列添加&删除节点
  * [二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/) / [二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/) / [二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/) 
  
* **非递归实现求二叉树的深度（小红书）** 
  * 引入队列，统计当前层次节点数目，逐层遍历
  * [二叉树的深度（递归和非递归）---java实现](https://blog.csdn.net/snow_7/article/details/51818580)
  * [102. 二叉树的层次遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)


* **非递归从左至右打印一颗二叉树中的所有路径（拼多多）**
  * [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/) 
* **判断平衡二叉树（腾讯）** 

  * [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/) 


* **红黑树描述及其复杂度分析（插入/查找）（腾讯/阿里）** *`TODO`*
  * 查找、插入、删除时间复杂度 --> O(logN)
  * [红黑树 Wiki](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)
  * [26 | 红黑树（下）：掌握这些技巧，你也可以实现一个红黑树](https://time.geekbang.org/column/article/68976)  *`TODO`* （红黑树分析，未细看）
* **将一颗二叉搜索树转化成一个排序的双向链表**
  * [二叉搜索树与双向链表](https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&tqId=11179&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) （不能创建新结点，画图找思路）


* **二叉树的最近公共祖先** *`TODO`*
  * 首先判断当前节点是否为指定结点，是则返回
  * 递归当前结点的左右子树
  * 如果两边均不为null，表示找到，返回当前结点，均为null则返回null，否则返回对应子节点（left / right）
  * [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/) 
  * [Lowest Common Ancestor Binary Tree](https://www.youtube.com/watch?v=13m9ZCB8gjw)（各种情况详细举例，推荐）


* **二叉树的中序遍历的下一个结点**
  * 先判断右子结点不为空，返回右子节点最左边的节点
  * 若父节点不为空，上溯到根节点的 “/”即返回
  * [二叉树的下一个结点](https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 


* **根据前&中序遍历结果重建二叉树**

  * 首先找到根节点，再划分左右子树区域，逐层递归找到左右子节点
  * [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) 
* **二叉树的直径 ** *`TODO`* 

  * [二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/) 
* **如何将一棵非平衡二叉树转化成平衡二叉树（HyperS）** *`TODO`*




### 链表/数组/栈/队列

* **反转链表（小红书/腾讯/头条）** 
  * [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/) 

* **复杂链表的复制**
  * 连接一个重复链表
  * 断链，拆分成两个链表
  * [138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/) 


* **约瑟夫环问题** 


  * 推数学公式 *`TODO`* / 蛮力法
  * [面试题62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/) 

  

### 字符串

* **如何找出一个字符串中的最大不重复子串（蜻蜓FM/美团）**
  * 滑动窗口 --> 滑动窗口直到最后一个元素，每当碰到重复时（可用一个Map记录，表示字母和位置），左指针往后走至当前位置，每轮都进行比较，取最大长度。 / 时间复杂度 --> O(n)
  * [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)


* **字符串的排列**
  * 深度优先搜索（DFS） + 剪枝
  * 理解递归的构造过程 --> 每次固定一个字符，继续处理剩余字符
  * 处理后还原交换（保证所有可能都被遍历到）
  * [面试题38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)
  * [46. 全排列](https://leetcode-cn.com/problems/permutations/) （相同思路）


* **至少有K个重复字符的最长子串**

  * 分治法，递归求解
  * 用一个map计数，一个set存储不应该包含的字母（即 count < k）
  * 双指针遍历字符串，一旦找到需要剔除的字符，判断该字符左右两边满足条件的最长子串，比较返回较大值

  * [395. 至少有K个重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/) 

  


### 动态规划


* **零钱兑换** 
  * [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)


* **鸡蛋掉落** *`TODO`* 
  * [887. 鸡蛋掉落](https://leetcode-cn.com/problems/super-egg-drop/) 


* **滑动窗口最大值** *`TODO`*
* [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)
* **单词拆分**  *`TODO`*
* [单词拆分 II](https://leetcode-cn.com/problems/word-break-ii/) 



### 回溯

* **正则表达式匹配**  *`TODO`*
  * [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/) 
* **单词拆分** *`TODO`*
  * [140. 单词拆分 II](https://leetcode-cn.com/problems/word-break-ii/)


* **分割回文串** *`TODO`*

  * [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/) 

  


### 图 (0/2)

* **课程表问题** *`TODO`*
  * DFS
  * [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)
  * [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)


* **岛屿数量（爱奇艺/依图）**

  * [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/) 





### 设计&场景 (0/12)

* **一个任务序列执行顺序如 A --> B1,B2,B3 --> C，如何保证该任务执行先后顺序的准确性（拼多多）**
  * 使用 CountDownLatch --> 可以让线程等待其它线程完成一组操作后才能执行，否则就一直等待
  * FutureTask 也是一种方案 --> 获得异步任务的执行结果
  * [23 | Future：如何用多线程实现最优的“烧水泡茶”程序？](https://time.geekbang.org/column/article/91292)
  * [CountDownLatch详解](https://www.jianshu.com/p/128476015902)


* **如何设计一个秒杀系统（小红书）**
  * 思路
    * 限流（过滤无效流量，如恶意脚本；拦截流量）
    * 削峰
    * 异步处理
    * 内存缓存（“多读少写”, "基于Redis来实现核心的业务逻辑"）
    * 消息队列缓存请求 --> “数据库层订阅消息减库存，减库存成功的请求返回秒杀成功，失败的返回秒杀结束”
  * [Java开发面试：高并发秒杀系统如何设计与优化](https://blog.csdn.net/CSDN_Terence/article/details/77744042)
  * [如何设计一个秒杀系统](https://blog.csdn.net/suifeng3051/article/details/52607544)
  * [秒杀系统架构优化思路](https://yq.aliyun.com/articles/69704?utm_campaign=wenzhang&utm_medium=article&utm_source=QQ-qun&utm_content=m_10737)
  * [如何设计一个百万级用户的抽奖系统](https://note.youdao.com/ynoteshare1/index.html?id=5c04dccbffd0b6fc511dc920e6be12e3&type=note)


* 高并发访问下如何保证用户名不冲突，比如多个用户同时创建同一个用户名（拼多多）*`TODO`* 


* **设计一个方案，提供不同算法调用接口（参数即为需要调用的方法名）（设计模式实际应用）（PayPal）**
  * 这题感觉非常开放，我当时答了用 适配器模式，似乎面试官并不是特别满意，感觉 适配器模式 属于结构型模式，主要用于解决兼容性问题，实际此题还是以如何创建为主，用 工厂模式 为宜
  * 工厂模式 (定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行) --> 传入方法参数，实例化具体对象
  * [两道设计模式的面试题](https://www.cnblogs.com/Binhua-Liu/archive/2010/12/23/1914935.html)
  * [工厂模式](https://www.runoob.com/design-pattern/factory-pattern.html)


* **设计一个方案，传入一个类型（如 圆形，矩形，三角形等），求对应的周长和面积，用设计模式更好（头条）**
  * 工厂模式，传入Shape 和一个用于保存参数的Map（或者别的存储方式？）
  * [工厂模式](https://www.runoob.com/design-pattern/factory-pattern.html)


* （爱奇艺项目相关）权限管理是如何设计的（星环） *`TODO`* 


* **谈一下synchronized 和 wait() 搭配使用的场景（星环）**
  * A `wait()` only makes sense when there is also a `notify()`, so it's always about communication between threads, and that needs synchronization to work correctly
  * [阿里巴巴面试题： 为什么wait()和notify()需要搭配synchonized关键字使用](https://blog.csdn.net/lengxiao1993/article/details/52296220) 
  * [Why must wait() always be in synchronized block](https://stackoverflow.com/questions/2779484/why-must-wait-always-be-in-synchronized-block)


* 设计一个表结构，用于记录高考之后学生的成绩，以及写一个查询得到某个城市的理科前十名（头条）*`TODO`* 


* **（项目相关）个人项目的查询引擎的AbstractProvider这种设计用到了什么模式（星环）**
  * 模板模式（Template Pattern）
  * 提取通用方法，便于维护
  * 封装不变部分，扩展可变部分
  * [模板模式](runoob.com/design-pattern/template-pattern.html)
* **已知某个类的路径，如何在代码中实例化这个类（星环）**
  * 获取Class对象 + newInstance() 实例化
  * [根据指定类名创建实例（Java的反射机制）](https://blog.csdn.net/u010729348/article/details/16819693)
* **实现一个线程安全的单例模式（星环）**
  * 懒汉模式 --> Lazy初始化
  * 饿汉模式 --> 在方法调用前，实例就已经创建好了
  * 全部 sychronized 锁住 --> 可以保证线程安全，但销效率低
  * “双重检查锁” 机制版本 （面试用，注意 `getInstance()` 方法 和对应 instance 实例 都需要 `static` 关键字修饰）
    * volatile 来保证其线程间的可见性，禁止指令重排序，保证返回的是初始化**完全**的对象
    * 同步代码块中使用二次检查，以保证其不被重复实例化
  * 枚举enum和静态代码块的特性相似，在使用枚举时，构造方法会被自动调用，利用这一特性也可以实现单例（面试也可稍微提及）
  * [高并发下线程安全的单例模式（最全最经典）](https://blog.csdn.net/cselmu9/article/details/51366946) （单例的N种实现）
  * [单例模式](https://www.runoob.com/design-pattern/singleton-pattern.html)（详尽介绍）
  * [Why is volatile used in double checked locking](https://stackoverflow.com/questions/7855700/why-is-volatile-used-in-double-checked-locking)


* 如何保证代码测试的覆盖率（开放题）（华为）



### 设计模式

* **简述设计模式**

  * 创建型 / 结构型 / 行为型
  * [第14讲 | 谈谈你知道的设计模式？](https://time.geekbang.org/column/article/8624)

* **实现一个线程安全的单例模式（星环）**

  * 懒汉模式 --> Lazy初始化
  * 饿汉模式 --> 在方法调用前，实例就已经创建好了
  * 全部 sychronized 锁住 --> 可以保证线程安全，但销效率低
  * “双重检查锁” 机制版本 （面试用，注意 `getInstance()` 方法 和对应 instance 实例 都需要 `static` 关键字修饰）
    * volatile 来保证其线程间的可见性，禁止指令重排序，保证返回的是初始化**完全**的对象
    * 同步代码块中使用二次检查，以保证其不被重复实例化
  * 枚举enum和静态代码块的特性相似，在使用枚举时，构造方法会被自动调用，利用这一特性也可以实现单例（面试也可稍微提及）
  * [高并发下线程安全的单例模式（最全最经典）](https://blog.csdn.net/cselmu9/article/details/51366946) （单例的N种实现）
  * [单例模式](https://www.runoob.com/design-pattern/singleton-pattern.html)（详尽介绍）
  * [Why is volatile used in double checked locking](https://stackoverflow.com/questions/7855700/why-is-volatile-used-in-double-checked-locking)

  


### 其他题型 (0/13)

* **买卖股票的最佳时机（野村证券/头条）**
  * [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/) 


* **斐波那契数列的尾递归实现（Wish）**
  * 尾递归就是把当前的运算结果（或路径）放在参数里传给下层函数，深层函数所面对的不是越来越简单的问题，而是越来越复杂的问题，因为参数里带有前面若干步的运算路径。
  * [递归与尾递归总结](https://www.cnblogs.com/Anker/archive/2013/03/04/2943498.html) 

* **1到10000有多少个数字7（头条，说思路即可）**
  * 答案 ：4000
  * [腾讯面试题-0到9999这1万个数中有多少个数字7](https://www.imooc.com/article/16642)（就是个思维题 ORZ...） 


* **整数中1出现的次数（从1到n整数中1出现的次数）** *`TODO`*
  * [整数中1出现的次数（从1到n整数中1出现的次数）](https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&tqId=11184&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)


* **实现一个二叉搜索树的迭代器，包括 next() 和 hasNext() 方法（PayPal）** *`TODO`*
  * [173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/solution/)


* **给定精度（如小数点后10位），写一个函数求根号2的具体值（拼多多/头条）** *`TODO`*
  * 牛顿法
  * [如何通俗易懂地讲解牛顿迭代法求开方？数值分析？](https://www.zhihu.com/question/20690553)
  * [69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/submissions/)


* **给定一个乱序数组[0,100]，替换其中一个数，找出这个数（头条）** *`TODO`*
  * 可修改数组版本 --> 根据下标，替换当前数字，直至下标和对应数字相等（nums[0] == 0, nums[1] == 1），遍历，直至得到第一个重复的数(nums[i] == nums[nums[i]])
  * 不可修改数组版本 --> 排序 / 集合 / 双指针（找到两个指针交点（`slow = nums[slow]; fast = nums[nums[fast]];`），然后一个从零开始，直至又到交点）
  * [数组中重复的数字](https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
  * [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)（不可修改数组版本，感觉不是很直观）


* **数组中只出现一次的数字** *`TODO`*
  * [数组中只出现一次的数字](https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&tqId=11193&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)


* **顺时针打印矩阵（星环）**
  * 寻找遍历次数规律，暴利求解
  * [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/solution/luo-xuan-ju-zhen-by-leetcode/) 
  * [顺时针打印矩阵](https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&tqId=11172&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)


* **单词接龙** *`TODO`*
  * 广度优先 --> 队列 + 暴力搜索（遍历过的删除）
  * [127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/solution/dan-ci-jie-long-by-leetcode/)
  * [花花酱 LeetCode 127. Word Ladder - 刷题找工作 EP71](https://www.youtube.com/watch?v=vWPCm69MSfs)


* **分数到小数**
  * 总结除法规律，按自然运算思考即可
  * 当余数出现循环，对应的商也会循环
  * 将除法过程代码化
  * [166. 分数到小数](https://leetcode-cn.com/problems/fraction-to-recurring-decimal/solution/fen-shu-dao-xiao-shu-by-leetcode/)
* **分糖果原题**
  * 从左至右扫一遍，再从右至左扫一遍，取最大值
  * [135. 分发糖果](https://leetcode-cn.com/problems/candy/)
* **滑动窗口最大值** *`TODO`*

  * [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)